ğŸ“œ Manual de EstÃ¡ndares: Clean Code & Pragmatic Thinking
Este documento rige el desarrollo del backend para garantizar un cÃ³digo mantenible, escalable y profesional.

ğŸ’ I. Pilares de Clean Code (Calidad de CÃ³digo)

1. Nombres con Sentido (Meaningful Names)
   - Variables y Funciones: Deben revelar su intenciÃ³n. Evita nombres genÃ©ricos como data, item o aux.
   - âŒ const d = 10;
   - âœ… const daysToPasswordExpiration = 10;
   - Nombres Pronunciables: Si no puedes explicar el nombre en una conversaciÃ³n, cÃ¡mbialo.
   - Funciones: Deben ser verbos (ej. sendRecoveryEmail, validateToken).

2. Funciones: PequeÃ±as y de PropÃ³sito Ãšnico (SRP)
   - Regla de las 20 lÃ­neas: Si una funciÃ³n supera las 20-30 lÃ­neas, probablemente estÃ¡ haciendo demasiado.
   - Un solo nivel de abstracciÃ³n: No mezcles lÃ³gica de alto nivel (enviar correo) con detalles de bajo nivel (manipulaciÃ³n de strings de HTML).
   - Argumentos: El nÃºmero ideal es cero o uno. Evita funciones con mÃ¡s de tres argumentos; en su lugar, pasa un objeto.

3. El Arte de Comentar (Tu ExcepciÃ³n Personalizada)
   - Aunque el Clean Code original es reacio a los comentarios, aquÃ­ los usaremos para documentar decisiones y arquitectura:
   - JSDoc obligatorio: Todas las funciones de los Services y Controllers deben llevar su bloque descriptivo.
   - Comentarios de "Por quÃ©": Ãšsalos para explicar por quÃ© se tomÃ³ una decisiÃ³n tÃ©cnica compleja (ej. una consulta SQL muy especÃ­fica).
   - Marcadores TODO: Ãšsalos para deuda tÃ©cnica inmediata, pero lÃ­mpialos antes de hacer el merge a la rama principal.

4. Formateo Uniforme
   - Usa Prettier y ESLint para asegurar que el cÃ³digo se vea igual sin importar quiÃ©n lo escriba.
   - Las variables se declaran cerca de donde se usan.

ğŸ› ï¸ II. The Pragmatic Programmer (Mentalidad)

1. DRY: Don't Repeat Yourself
   - No se trata solo de no copiar y pegar cÃ³digo. Se trata de que cada pieza de conocimiento debe tener una representaciÃ³n Ãºnica en el sistema. Si cambias la lÃ³gica del 2FA, solo deberÃ­a cambiarse en un lugar (2fa.service.js).

2. Ortogonalidad (Desacoplamiento)
   - Tus componentes deben ser independientes. Si cambias la base de datos de MariaDB a otra, el cÃ³digo de envÃ­o de correos (Nodemailer) no deberÃ­a enterarse ni romperse.

3. Rompe las Ventanas Rotas
   - No ignores errores pequeÃ±os o advertencias en la consola. Un cÃ³digo "descuidado" invita a otros desarrolladores a seguir descuidÃ¡ndolo. Si ves algo mal, arrÃ©glalo en el momento.

4. ProgramaciÃ³n por Contrato
   - Define quÃ© espera recibir cada funciÃ³n (validaciÃ³n con Express Validator) y quÃ© garantiza devolver. No confÃ­es ciegamente en los datos de entrada.

ğŸ—ï¸ III. ImplementaciÃ³n TÃ©cnica en el Backend

- Manejo de Errores (Fail Fast)
  - Pragmatic Tip: Deja que el programa falle rÃ¡pido. Usa bloques try/catch en los controladores para capturar excepciones y pasarlas al middleware global de errores.

- Seguridad y Secretos
  - No seas una vÃ­ctima: Nunca guardes contraseÃ±as en texto plano (usa Bcryptjs).
  - No "hardcodees" credenciales. Usa el principio de ConfiguraciÃ³n Externa.

ğŸ“‹ Checklist de RevisiÃ³n (Code Review)
Antes de dar por terminada una tarea, verifica:

[ ] Â¿La funciÃ³n hace solo una cosa?
[ ] Â¿Las variables tienen nombres descriptivos en camelCase?
[ ] Â¿Hay lÃ³gica repetida que pueda extraerse a un Util o Service?
[ ] Â¿He incluido comentarios JSDoc en las funciones nuevas?
[ ] Â¿La respuesta de la API sigue el formato estÃ¡ndar del proyecto?
